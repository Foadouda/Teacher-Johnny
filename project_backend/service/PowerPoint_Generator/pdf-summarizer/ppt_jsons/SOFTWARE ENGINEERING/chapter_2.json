{
    "book_name": "SOFTWARE ENGINEERING",
    "chapter": 2,
    "title": "Software Processes",
    "slides": [
        {
            "slide_number": 1,
            "title": "Software Processes: Introduction",
            "content": [
                "A software process encompasses activities leading to a software product, involving development or evolution.",
                "This includes software specification, design, implementation, validation, and continual evolution.",
                "Activities such as architectural design and user interface development are included in software processes.",
                "Process descriptions may incorporate process activities, roles, products, pre- and post-conditions for clarity.",
                "Software processes are often categorized as plan-driven or agile, needing a balance for different software types.",
                "Processes should continuously evolve, as technology is changing, impacting business or organizations."
            ],
            "script": "Hello everyone, welcome to our discussion on software processes. This slide introduces the fundamental idea that software engineering is built around well-defined activities, leading to a deliverable software product. Key activities that software engineers undertake including requirements, design, coding, testing, and long-term evolution. This slide highlights that process descriptions are comprehensive, going beyond just the steps to include roles, deliverables, and before/after conditions. Finally, we touch on the need for software processes to change with the business to ensure quality and efficiency."
        },
        {
            "slide_number": 2,
            "title": "Software Process Models",
            "content": [
                "A software process model is a simplified abstraction that represents a software process from a specific perspective.",
                "Generic models act as frameworks adapted and extended for specific software engineering processes and project needs.",
                "Common process models include waterfall, incremental development, and reuse-oriented software engineering techniques.",
                "The waterfall model is plan-driven with separate phases for specification, design, implementation, testing, and maintenance.",
                "Incremental development interleaves specification, development, and validation activities, delivering software in increments.",
                "Reuse-oriented development focuses on integrating existing components rather than building everything from scratch; more reuse.",
                "Process models aren\u2019t mutually exclusive; large projects often combine the best features of multiple processes for efficiency."
            ],
            "script": "This slide explores the major software process models. These are simplified representations of how software development can be structured. We'll look at the classic waterfall model, a sequential approach, and contrast that with incremental development, which is iterative. We'll also introduce reuse-oriented development, where leveraging existing components is paramount. Note that these aren't mutually exclusive; projects can and often do, blend elements of each model. "
        },
        {
            "slide_number": 3,
            "title": "The Waterfall Model",
            "content": [
                "Requirements analysis and definition with system constraints defined in detail through customer consultation.",
                "System and software design allocating requirements to hardware or software, establishing overall system architecture.",
                "Implementation and unit testing realizing design as programs, verifying that each unit meets specifications.",
                "Integration and system testing combining units to ensure requirements are met, then delivering the software.",
                "Operation and maintenance correcting errors, improving units, and enhancing services based on new requirements.",
                "Feedback exists between phases, documents are modified, but premature freezing of specifications can cause problems.",
                "The waterfall model is consistent with engineering models, easy to manage, but can be inflexible to changing requirements."
            ],
            "script": "Here, we delve deeper into the waterfall model, which is derived from more general engineering project management. This model features a cascading of phases, starting with requirements and ending with operations and maintenance. Each phase should be 'signed off' before proceeding, and feedback loops are present. While it's easy to manage and document, it is susceptible to increased costs if rework must be done, and is very inflexible."
        },
        {
            "slide_number": 4,
            "title": "Incremental Development Model",
            "content": [
                "Incremental development delivers software in increments after user feedback and refinement through multiple versions.",
                "Specification, development, and validation activities are interleaved, enabling rapid feedback across all activities.",
                "Compared to the waterfall model, incremental development reduces the cost of accommodating changing requirements.",
                "It allows easier customer feedback on the development work that has already been completed.",
                "Incremental development enables faster delivery and deployment of useful software to customers.",
                "Increment delivery may take both plan-driven and agile-driven approaches; agile development is most common."
            ],
            "script": "Now we will move to the Incremental Development Model, where the system is developed in a series of versions or increments. Specification, development, and validation are interleaved, which allows rapid feedback. This approach reduces the cost of changes, facilitates customer feedback, and enables faster deployment. Incremental delivery may take both plan-driven and agile-driven approaches."
        },
        {
            "slide_number": 5,
            "title": "Reuse-Oriented Software Engineering Model",
            "content": [
                "Requirements specification and validation stages are similar to other software processes; intermediate stages are different.",
                "Component analysis searches for components to implement specifications, but an exact match may not exist.",
                "Requirements modification adjusts specifications using component information; component analysis may be re-entered.",
                "System design with reuse designs a system framework or reuses an existing framework.",
                "Development and integration develop software that cannot be externally procured, and integrate reusable components.",
                "Commercial off-the-shelf (COTS) systems and software components as web services are often integrated in this model."
            ],
            "script": "Reuse-oriented software engineering focuses on integrating existing software components, such as web services or COTS, rather than building everything from scratch. A search is made for usable components, requirements are adapted to fit them, and a framework is designed, or reused, to incorporate them. COTS systems, or Commercial Off-The-Shelf systems, are commonly integrated for the development of new software."
        },
        {
            "slide_number": 6,
            "title": "Software Specification",
            "content": [
                "Software specification, or requirements engineering, defines the software's services and constraints on operation.",
                "It's a critical stage where errors can lead to design and implementation issues, therefore requirements should be developed incrementally.",
                "The requirements engineering process aims to produce a document specifying stakeholder requirements.",
                "Requirements are presented on different detail levels: high level for end-users and detailed system specification for developers.",
                "Processes include: feasibility study, requirements elicitation and analysis, requirements specification, and validation."
            ],
            "script": "Software specification, also called requirements engineering, is where we define the software's purpose and its constraints. This is a crucial phase, as errors here can propagate into serious design and implementation flaws. It also includes feasibility studies, requirements elicitation/analysis, requirements specification, and requirements validation."
        },
        {
            "slide_number": 7,
            "title": "Software Design and Implementation",
            "content": [
                "Implementation converts system specifications into an executable system involving design and programming.",
                "A design is a description of the software structure, data models, interfaces, and algorithms.",
                "The diagram describes various design stages: architectural, interface, component, and database.",
                "Most software interfaces with other systems, thus designers must decide how best to integrate with the environment.",
                "Programming is a personal activity, with skeleton programs generated from designs and programming components reused.",
                "Software development tools may be used to generate a skeleton program from a design. "
            ],
            "script": "Moving on to the implementation phase, we're converting specifications into an executable system. Software design involves iterative refinement, adding formality and detail as we progress. Design inputs include requirements, platform information, and data descriptions. Activities are architectural, interface, component, and database design, leading to outputs such as system architecture, interface specifications, etc."
        },
        {
            "slide_number": 8,
            "title": "Software Validation",
            "content": [
                "Software validation, or Verification and Validation (V&V), checks system conformance and meets customer expectations.",
                "Program testing is the principal validation technique, with a majority of costs incurred during or after implementation.",
                "Testing occurs in stages: development testing, system testing, and acceptance testing.",
                "Each stage is iterative; program must be debugged and certain testing processes may need to be repeated.",
                "If incremental approach to development is used, each increment should be tested based on the requirements.",
                "Test plans are important for a plan-driven software process for quality control."
            ],
            "script": "Software validation, or V&V, aims to ensure the system meets both its specifications and customer expectations. Program testing is key, but it's a multi-stage process, starting with testing individual components, integrating the system, and finally, acceptance testing with real data. The process is iterative, allowing feedback and adjustments along the way."
        },
        {
            "slide_number": 9,
            "title": "Software Evolution",
            "content": [
                "Flexibility of software systems drives their increasing incorporation into complex systems.",
                "Changes can be made at any point of software or after it has been developed.",
                "Distinction between development and maintenance processes is becoming irrelevant.",
                "Software engineering is an evolutionary process, changing over its lifetime.",
                "Systems respond to changing requirements and customer needs during evolution.",
                "Making sure the code is reusable is an important aspect of this process."
            ],
            "script": "Software evolution is a continuous cycle. It's about recognizing that software is never truly finished, that changing requirements and customer needs drive ongoing adaptations and enhancements. The distinction between initial development and later maintenance is blurring, leading to a continuous feedback loop."
        },
        {
            "slide_number": 10,
            "title": "Coping with Changing Requirements",
            "content": [
                "Change is inevitable to all large software projects due to business/management priorities and technologies.",
                "Change adds to costs (rework) so there is two ways to reduce costs; avoidance or tolerance.",
                "Change avoidance anticipate changes before rework is required. Develop prototype system to show key features.",
                "Change tolerance Process is designed to accommodate changes at relatively low cost.",
                "System prototyping allows experimenting before committing production costs. Important for both change avoidance and tolerance.",
                "Incremental delivery delivers system increments for customer comment; supporting change avoidance and tolerance."
            ],
            "script": "This slide gets to an extremely important aspect of modern software engineering; coping with change. Change adds costs, through rework. There are two strategies: change avoidance, preventing changes before they require rework, and change tolerance designing the processes so that accommodating change costs less. Prototyping and incremental delivery are mechanisms for both."
        },
        {
            "slide_number": 11,
            "title": "System Prototyping",
            "content": [
                "Software prototypes are initial versions used to demonstrate concepts, test designs, and find more about problems.",
                "Essential for rapid iteration, cost control, and stakeholder experimentation.",
                "Software prototypes helps anticipate changes during requirements engineering and explore solutions during system design.",
                "Users can assess the system by strengths and weaknesses, then propose new system requirements.",
                "Explicit objectives are essential so objectives don't get misunderstood and value is gained.",
                "Relaxing non-functional requirements reduce prototypes costs and accelerates delivery."
            ],
            "script": "System Prototyping is a crucial technique for managing change. Prototypes are initial versions used to demonstrate ideas, explore design options, and gather more information. You can experiment with prototypes to refine your needs. If the objectives are unstated, management or end-users may misunderstand the function of the prototype. "
        },
        {
            "slide_number": 12,
            "title": "Incremental Delivery",
            "content": [
                "Incremental delivery is an approach for software development where some increments are deployed in operation.",
                "Customers identify services in outline and select what is most and least important to them.",
                "A number of delivery increments are defined, delivering subsets of system functionality.",
                "After the increment is completed, the customers can make changes if it doesn't deliver what is required.",
                "The process will maintain the benefits of the incremental development so changes can be incorporated to the system.",
                "Incremental delivery can serve as models for prototying and allows to get more feedback."
            ],
            "script": "Incremental delivery involves delivering and deploying system increments, giving the customer early access to part of the functionality. Key advantages include customers being able to provide feedback on early increments, and customers gain value from it earlier."
        }
    ]
}